import Image from "next/image";

# redux 源码分析
2023/07/02

> 本文不涉及任何 redux 使用技巧，适合使用过 redux 的开发人员阅读。<br/>
> 开发中，一般能接触到的库是 react-redux 或 @reduxjs/toolkit，因此可能需要了解一些基本的 redux 的使用方法。<br/>
> 基本方法：[https://codesandbox.io/s/redux-example-rp99f4?file=/src/index.ts](https://codesandbox.io/s/redux-example-rp99f4?file=/src/index.ts)

## 知识准备

相关代码均基于 `redux v5.0.0-beta.0` 解析。在 redux 代码中，涉及到较多的柯里化函数和函数组合。网络上相关的文档很多，可以自行搜索学习，不在做多余的阐述。

> 相关参考：[柯里化](https://zh.wikipedia.org/zh-sg/%E6%9F%AF%E9%87%8C%E5%8C%96)以及[复合函数](https://zh.wikipedia.org/wiki/%E5%A4%8D%E5%90%88%E5%87%BD%E6%95%B0)

项目结构思维导图：

<Image
  src="/images/redux-analyses.png"
  alt="redux-analyses"
  width={1008}
  height={305}
  loading="lazy"
/>
注意：redux 5.x 版本中，将 `createStore` 纳入弃用，并推荐使用 @reduxjs/toolkit 来开发，与 react 深度绑定。为了分析 redux 在通用框架中使用，仍会去分析 `createStore` 相关代码。

## 创建 store / createStore

通过查看 `createStore` 的函数签名，可以得知其可以传入多个参数，其中 `reducer` 是必传参数。

```javascript
const store = createStore(reducer, [preloadedState], [enhancer]);
```

源码标注解读（省略部分逻辑）

```javascript
function createStore(reducer, preloadedState, enhancer) {
	// 检查 reducer 是否为函数
	if (typeof reducer !== 'function') { /* ... */}
	// 检查是否传入了多个增强函数，createStore 只支持一个增强函数，建议使用 compose 函数将多个函数组合
	if (
	(typeof preloadedState === 'function' && typeof enhancer === 'function') ||
	(typeof enhancer === 'function' && typeof arguments[3] === 'function')
	) { /* ... */ }
	// 继续检测输入
	if (typeof preloadedState === 'function' && typeof enhancer === 'undefined'){
		enhancer = preloadedState
		preloadedState = undefined
	}
	// 如果有增强函数且增强函数为 function 类型，那么通过增强函数在调用一次 createStore 方法
	if (typeof enhancer !== 'undefined') {
		if (typeof enhancer !== 'function') { /* ... */ }
		return enhancer(createStore)(reducer, preloadedState)
	}

	let currentReducer = reducer
	let currentState
	let currentListeners = new Map()
	let nextListeners = currentListeners
	let listenerIdCounter = 0
	let isDispatching = false

	// 判断是否可以修改 nextListeners
	// dispatch 中执行的订阅是 nextListeners 中的内容
	function ensureCanMutateNextListeners() {
		if (nextListeners === currentListeners) {
			nextListeners = new Map()
			currentListeners.forEach((listener, key) => {
				nextListeners.set(key, listener)
			})
		}
	}

	// 获取当前 state
	function getState() {
		// 如当前正在执行 reducer，则抛出异常
		if (isDispatching) { /* ... */ }
		return currentState
	}

	// 注册 listener，返回取消事件注册的方法。当调用 dispatch 的时候调用 listener
	function subscribe(listener) {
		// 检查参数
		if (typeof listener !== 'function') { /* ... */ }
		//  如当前正在执行 reducer，则抛出异常
		if (isDispatching) { /* ... */ }
		// 状态位，用于判断是否已经取消监听
		let isSubscribed = true
		ensureCanMutateNextListeners()
		const listenerId = listenerIdCounter++
		// 注册事件
		nextListeners.set(listenerId, listener)
		return function unsubscribe() {
			if (!isSubscribed) return
			//  如当前正在执行 reducer，则抛出异常
			if (isDispatching) { /* ... */ }
			isSubscribed = false
			ensureCanMutateNextListeners()
			// 移除事件
			nextListeners.delete(listenerId)
			currentListeners = null
		}
	}

    // dispatch 执行 action
	function dispatch(action) {
		// 确保输入是一个对象
		if (!isPlainObject(action)) { /* ... */ }
		// 确保 action 存在 type 属性
		if (typeof action.type === 'undefined') { /* ... */ }
		if (typeof action.type !== 'string') { /* ... */ }
		// 确保当前没有别的 reducer 在执行
		if (isDispatching) { /* ... */ }
		// 执行 reducer
		try {
			isDispatching = true
			currentState = currentReducer(currentState, action)
		} finally {
			isDispatching = false
		}
		// 执行订阅
		// 执行订阅的时候使用的是 nextListeners 中的监听函数
		const listeners = (currentListeners = nextListeners)
		listeners.forEach(listener => {
			listener()
		})
		return action
	}

	// 替换 reducer 函数
	function replaceReducer(nextReducer) {
		// 参数校验
		if (typeof nextReducer !== 'function') { /* ... */ }
		currentReducer = nextReducer
		// 生成新的 store 树
		dispatch({ type: ActionTypes.REPLACE })
	}

	// 预留，使用浏览器的 observable API
	function observable() {
		const outerSubscribe = subscribe

		return {
			subscribe(observer: unknown) {
				if (typeof observer !== 'object' || observer === null) { /* ... */ }
				function observeState() {
					const observerAsObserver = observer
					if (observerAsObserver.next) {
						observerAsObserver.next(getState())
					}
				}
				observeState()
				const unsubscribe = outerSubscribe(observeState)
				return { unsubscribe }
			},

			[$$observable]() {
				return this
			}
		}
	}

	// 初始化 store 树
	// ActionTypes.INIT 一般情况下不会在 reducer 中出现，返回默认值
	dispatch({ type: ActionTypes.INIT })

	const store = {
		dispatch,
		subscribe,
		getState,
		replaceReducer,
		[$$observable]: observable
	}

	return store
}
```


## 中间件 / applyMiddleware

`applyMiddleware` 接受多个中间件，生成 enhancer 函数。

通过分析 `createStore` 源码得知，当 `enhancer` 存在时，会返回 `enhancer(createStore)(reducer, preloadedState)` 。

源码标注解读（省略部分逻辑）

```javascript
function applyMiddleware(...middlewares) {
	return createStore => (reducer, preloadedState) => {
		// 调用 createStore 生成 store
		const store = createStore(reducer, preloadedState)
		let dispatch = () => {}
		// 定义中间件的参数，包括 getState 和 dispatch
		const middlewareAPI = {
			getState: store.getState,
			dispatch: (action, ...args) => dispatch(action, ...args)
		}
		// 生成中间件函数
		const chain = middlewares.map(middleware => middleware(middlewareAPI))
		// 将中间件函数组合并应用到 dispatch 上，生产新的 dispatch 函数
		dispatch = compose(...chain)(store.dispatch)
		return {
			...store,
			dispatch
		}
	}
}
```

以为 `redux-thunk` 为例，分析中间件的加载过程。

> 分析 `createStore` 源码得知，`dispatch` 只接受一个对象类型的参数，在实际使用中，可以传入一个函数名称，其中就使用了 `redux-thunk` 。

```javascript
function createThunkMiddleware(extraArgument) {
	// 接受 dispatch 和 getState 作为参数
	// 通过对 applyMiddleware 分析得知 next 参数为 store.dispatch
	const middleware  = ({ dispatch, getState }) =>
	next =>
	action => {
		// 如果 action 是一个函数，则返回执行后的参数
		// 同时要求 action 的参数具有 action(dispatch, [getState], [extraArgument]) 的签名
		if (typeof action === 'function') {
			return action(dispatch, getState, extraArgument)
		}
		return next(action)
	}

	return middleware
}
```


## 合并 reducer / combineReducers

`combineReducers` 可以讲多个 reducer 组合成一个 reducer，方便拆分逻辑，以保持可维护性。

在分析 `combineReducers` 之前，需要分析一些用到的辅助函数。

`assertReducerShape` 函数遍历传入的 reducers，检测传入的 reducers 是否合法。

```javascript
function assertReducerShape(reducers: {}) {
	Object.keys(reducers).forEach(key => {
		const reducer = reducers[key]
		// 初始化 state，默认会走的 default 路径
		const initialState = reducer(undefined, { type: ActionTypes.INIT })
		if (typeof initialState === 'undefined') { /* ... */ }
		if (typeof reducer(undefined, {type: ActionTypes.PROBE_UNKNOWN_ACTION()}) === 'undefined') { /* ... */ }
	})
}
```

源码标注解读（省略部分逻辑）

```javascript
function combineReducers(reducers: {}) {
	const reducerKeys = Object.keys(reducers)
	const finalReducers = {}
	// 只接受 function 类型的 reducer
	for (let i = 0; i < reducerKeys.length; i++) {
		const key = reducerKeys[i]
		if (process.env.NODE_ENV !== 'production') {
			if (typeof reducers[key] === 'undefined') { /* ... */ }
		}
		if (typeof reducers[key] === 'function') {
			finalReducers[key] = reducers[key]
		}
	}
	const finalReducerKeys = Object.keys(finalReducers)
	// 异常
	let unexpectedKeyCache
	if (process.env.NODE_ENV !== 'production') {
		unexpectedKeyCache = {}
	}

	let shapeAssertionError
	try {
		// 检查传入 reducer 的 state 是否合法
		assertReducerShape(finalReducers)
	} catch (e) {
		shapeAssertionError = e
	}
	// 返回一个function。该方法接收 state 和 action 作为参数
	return function combination(state, action) {
		// 若 state 不合法, 抛出异常
		if (shapeAssertionError) {
			throw shapeAssertionError
		}
		// 开发环境提示一些警告信息
		if (process.env.NODE_ENV !== 'production') {
			const warningMessage = getUnexpectedStateShapeWarningMessage(
				state, finalReducers, action, unexpectedKeyCache
			)
			if (warningMessage) warning(warningMessage)
		}

		let hasChanged = false
		const nextState = {}
		// 遍历 finalReducerKeys，并执行对应 reducer
		for (let i = 0; i < finalReducerKeys.length; i++) {
			const key = finalReducerKeys[i]
			const reducer = finalReducers[key]
			// 从 state 中获取当前 key 对应的值
			const previousStateForKey = state[key]
			// 计算更新后的值
			// 假设 action 不存在，则 reducer 返回默认值，不会为 undefined
			const nextStateForKey = reducer(previousStateForKey, action)
			// reducer 返回 undefined 则抛出错误
			if (typeof nextStateForKey === 'undefined') { /* ... */ }
			// 更新 nextState 的值
			nextState[key] = nextStateForKey
			// 判断是否修改过
			hasChanged = hasChanged || nextStateForKey !== previousStateForKey
		}
		// 再次判断是否修改过
		hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length
		// 根据是否修改来判断返回的数据
		return hasChanged ? nextState : state
	}
}
```


## bindActionCreator

`bindActionCreators` 在日常开发中用的较少，其功能是将 action 与 dispatch 包装在一起，方便直接调用它们。

```javascript
function bindActionCreator(actionCreator,dispatch) {
	return function (this, ...args) {
		return dispatch(actionCreator.apply(this, args))
	}
}

function bindActionCreators(actionCreators, dispatch) {
	if (typeof actionCreators === 'function') {
		return bindActionCreator(actionCreators, dispatch)
	}
	// 参数检验
	if (typeof actionCreators !== 'object' || actionCreators === null) {/* ... */}
	const boundActionCreators = {}

	for (const key in actionCreators) {
		const actionCreator = actionCreators[key]
		if (typeof actionCreator === 'function') {
			// 创建执行函数
			boundActionCreators[key] = bindActionCreator(actionCreator, dispatch)
		}
	}
	return boundActionCreators
}
```
